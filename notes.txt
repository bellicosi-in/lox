//variable declaration
Variable declaration parsing begins in varDeclaration() 
and relies on a couple of other functions. 
First, parseVariable() consumes the identifier token for the variable name,
adds its lexeme to the chunk’s constant table as a string, and
then returns the constant table index where it was added. 
Then, after varDeclaration() compiles the initializer, 
it calls defineVariable() to emit the bytecode for storing the variable’s value in the global variable hash table.

“Declaring” is when the variable is added to the scope, and “defining” is when it becomes available for use.


NOTES:
CHUNKS OF BYTECODE:
1. To use the cache effectively , the way we represent code in memory should be dense and ordered like its read.
2. writing in bytecode means that we are ensuring portability as well as fast. vm is a simulated chip written in software that interprets the 
bytecode one instruction at a time.
3. each chunk will carry with it a list of the values that appear as literals in the program. To keep things simpler, we'll put all constants in there, even simple integers.


A VIRTUAL MACHINE
1. This is the backend. it executes the instructions. you hand it a chunk of code and it  literally runs it.
2. VM detects runtime errors and compiler detects the static errors. 
3. each turn through the loop in run we execute a sinlge bytecode instruction.
4. the ip tracks the bytecode through the chunk thats passed to the vm. ip always points to the instruction about to be executed.
5. in the VM the code goes through Interpret to run() where the major function is happening.  we also disassemble the instructions.
6. this is the stack based vm. but there is another vm which is the register based vm. in this the local variables live on the stack.

SCANNING ON DEMAND:
1. clox has three phases : a scanner, a compiler and a virtual machine.
2. tokens flow from scanner to compiler and chunks of bytecode from compiler to vm. 
3.the compiler initializes the scanner. 
4.the pipeline to scan, compile and execute is driven by interpret(). 
5. define scanToken(). then use the scanner to makeToken.
6. to identify reserved keywords, we use trie. each string trie contains is represented as a path through the tree of character nodes, as in our traversal above. 
7. this is the phase of lexical analysis.
8. for more info on state machines : craftinginterpreters.com/state

COMPILING EXPRESSIONS
1. A compiler has roughly two jobs : it parses the user's source code to understand what it means(semantic analysis) and then it takes that knowledge and outputs low level instructions
that produce the same semantics.
2. in this we will build the parsing and code generation first and then stitch them together with the code in the middle that uses Pratt's technique to parse lox's particular grammar,
and output the right bytecode.
3. front half of the compiler - define the advance function that goes to the next valid token and handles errors.
4. after we parse and understand a piece of the user's program, the next step is to translate that to a series of btyecode instructions.
5.we are defining relevant functions to deal with each type of token that we get after being parsed.
6.expressions that start with a particular expression are called prefix expressions.
7.binary operators are infix expressions.

TYPES OF VALUES:
1. define a value struct that has support for different kinds of values. 

STRINGS
1. using stack to store the smaller, atomic values and heap for larger, variable sized values, leads to 2 level representation.
2. data that lives on the heap will maintain a similar state for the garbage collector. we will call it obj
3.Because ObjString is an Obj, it also needs the state all Objs share. It accomplishes that by having its first field be an Obj. 
C specifies that struct fields are arranged in memory in the order that they are declared. 
Also, when you nest structs, the inner struct’s fields are expanded right in place

4. Objstring -> string -> copyString -> ALLOCATE -> reallocate -> heapChars -> allocateString -> allocateObject
                            |_____________________________________________________|


HASH TABLES
1. Hash table - a set of keys and values.
2.A hash function takes some larger blob of data and “hashes” it to produce a fixed-size integer hash code whose value depends on all of
 the bits of the original data. it has three main goals :
 a. it must be deterministic
 b. it mmust be uniform
 c. it must be fast.
3. the ratio of load count to capacity is the load factor.
4. we can use the hash table to look up the variables and the values associated with it. 
5. we need a way to take string and convert it into a fixed size integer. 
6. each objstring stores the hash code for its string
7. string interning - create a collection of internal strings.  you only add unique strings to the collection.

GLOBAL VARIABLES
1. declarations are those statements that bind a new name to a value.
2. the other kind of statements - control flow, print etc. are just called statements.
3. each expression leaves one result value on stack. while the total net effect on the stack of a statement is 0.
4.  table globals is the hash table where the variables(global) gets stored.

LOCAL VARIABLES
1. for local variables, we dont need to stuff the variable's name into the constant table, so if the declaration is inside a local scope,
we return a dummy table index instead. 
2. there's no code to create a local variable at runtime
3. the compiler does need to remember that the variable exists for local variable.
4. “Declaring” is when the variable is added to the scope, and “defining” is when it becomes available for use.


JUMPING BACK AND FORTH
1.by flow we mena the way execution moves through the text of the program.
2. the VM's ip field stores the address of the current bytecode instruction. the value of that field is exactly "where we are " in the program.
3. to skip over a chunk of code, we simply set the ip field to the address of the bytecode instructions following that code. 