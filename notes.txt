//variable declaration
Variable declaration parsing begins in varDeclaration() 
and relies on a couple of other functions. 
First, parseVariable() consumes the identifier token for the variable name,
adds its lexeme to the chunk’s constant table as a string, and
then returns the constant table index where it was added. 
Then, after varDeclaration() compiles the initializer, 
it calls defineVariable() to emit the bytecode for storing the variable’s value in the global variable hash table.

“Declaring” is when the variable is added to the scope, and “defining” is when it becomes available for use.


NOTES:
CHUNKS OF BYTECODE:
1. To use the cache effectively , the way we represent code in memory should be dense and ordered like its read.
2. writing in bytecode means that we are ensuring portability as well as fast. vm is a simulated chip written in software that interprets the 
bytecode one instruction at a time.


A VIRTUAL MACHINE
1. This is the backend. it executes the instructions. you hand it a chunk of code and it  literally runs it.
2. VM detects runtime errors and compiler detects the static errors. 
3. each turn through the loop in run we execute a sinlge bytecode instruction.


SCANNING ON DEMAND:
1. clox has three phases : a scanner, a compiler and a virtual machine.
2. tokens flow from scanner to compiler and chunks of bytecode from compiler to vm. 
3.the compiler initializes the scanner. 


JUMPING BACK AND FORTH
1.by flow we mena the way execution moves through the text of the program.
2. the VM's ip field stores the address of the current bytecode instruction. the value of that field is exactly "where we are " in the program.
3. to skip over a chunk of code, we simply set the ip field to the address of the bytecode instructions following that code. 